# Diagnostic Medicare Center Management System


A Diagnostic Medicare Center Management System (DMS), is a system used for maintaining the details of the "Diagnostic Medicare System". It provides several operations booking an apointment, creating an account for the customer who wants to be a member of the Diagnostic center, to search for a Medicare service, to apply for any health checkup, to find a medical insurance agent and services and to view the medical reports online.

The following are the few important modules in the system:  
a.	To create an account for the new customer   
b.	To search for any Medicare service.  
c.	 Apply for any health checkup   
d.	To find an medical Insurance agent and services  
e.	To view the medical report online.  



---

## üîß 1. ‚ùì What is the Problem?
In many healthcare environments, especially diagnostic centers and clinics, the process of managing health checkup applications, user records, and test scheduling is still manual or semi-automated. This leads to:

- Inefficiencies in handling patient data and appointments.
- Delays in processing health checkup applications.
- Errors in record-keeping and communication.
- Lack of transparency for patients regarding their application status or test results.


### üéØ Motivation Behind Building It
The goal is to digitize and streamline the diagnostic process by creating a centralized system that:

  - Allows users to apply for health checkups online.
  - Enables diagnostic centers to manage applications, users, and test packages efficiently.
  - Reduces administrative overhead and improves accuracy.
  - Provides real-time status updates to users.
  - Enhances data security and accessibility.
    
*This system is especially valuable in the post-pandemic world, where contactless and remote healthcare services are increasingly important.


  ### üë• Target Users / Beneficiaries

  #### Patients / Customers:
  
      Can apply for health checkups online.
      Track the status of their applications.
      View available health packages and choose accordingly.
  
  #### Diagnostic Center Staff / Admins:
    
      Manage user applications and appointments.
      Assign or approve health checkups.
      Monitor system reports and analytics.
  
  #### Healthcare Providers / Doctors:
    
      Access patient application history.
      Recommend appropriate checkups based on history.
      System Integrators / Developers:
  
  Can extend the system to integrate with labs, hospitals, or insurance providers.

---

## üß± 2. System Architecture Overview

 

---

## üß™ 3. Core Features & Functionality
- Highlight key features implemented in the backend:
  - REST APIs
  - Authentication/Authorization
  - Business logic
  - Data persistence
- We used Swagger UI, or Postman to demonstrate API endpoints.

---

## üß∞ 4. Tech Stack & Tools
- **Spring Boot** (3.5.0)
- **Database**: MySQL, PostgreSQL
- **JPA/Hibernate**
- **Security**: Spring Security, JWT
- **Testing**: JUnit, Mockito
- **Build Tools**: Maven

---

## üì¶ 5. Code Walkthrough (Brief)
- Show important parts of the code:
  - Controller
  - Service
  - Repository
  - DTOs and Models
- Emphasize clean architecture and design patterns used (e.g., MVC, layered architecture).

- Major entities that going to covers our project are as given-
    #### Entities
    - AppUser             ->    Used for creating a customer
    - Appointment         ->    Used for creating a customer
    - Insurance Agent     ->    
    - Medicare Service    ->    To search the medicare services based on the keyword 
    - Health Checkup      ->    To apply for health checkup, search health checkup, and select health checkup pakage or plan
    - Medical Reports    ->    To search the medicare services based on the keyword 


      
    #### Field Descriptions (AppUser)
      - @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id;
      
        Purpose: Primary key for the entity.
        Behavior: Automatically generated by the database (auto-incremented).
        Annotation: @Id marks it as the primary key; @GeneratedValue with IDENTITY strategy delegates ID generation to the database.
      - @Column(unique = true) @NotBlank @Size(...) private String userId;
      
        Purpose: Unique identifier for the user (e.g., username or login ID).
        Constraints:
        Must not be blank.
        Must be between 4 and 50 characters.
        Must be unique in the database.
      - @Column @NotBlank @Size(...) private String userName;
      
        Purpose: Full name of the user.
        Constraints:
        Must not be blank.
        Maximum length of 100 characters.
      - @NotBlank @Pattern(...) private String contactNumber;
      
        Purpose: User's mobile number.
        Constraints:
        Must not be blank.
        Must match a valid 10-digit Indian mobile number starting with 6‚Äì9.
      - @Column(name = "password") @NotBlank @Pattern(...) private String password;
      
        Purpose: User's password.
        Constraints:
        Must not be blank.
        Must contain at least one digit, one lowercase letter, one uppercase letter.
        Minimum length of 8 characters.
      - @Column(name = "date_of_birth") @NotNull @Past @JsonFormat(...) private LocalDate dateOfBirth;
      
        Purpose: User's date of birth.
        Constraints:
        Must not be null.
        Must be a date in the past.
        Formatted as dd-MM-yyyy in JSON.
      - @Column(name = "email_id", unique = true) @NotBlank @Email private String emailId;
      
        Purpose: User's email address.
        Constraints:
        Must not be blank.
        Must be a valid email format.
        Must be unique in the database.
      - @Column(name = "status", nullable = false) private Integer status;
      
        Purpose: Represents the user's status (e.g., active, inactive).
        Behavior: Defaults to 0 (possibly inactive) if not set before persisting.
      - @ManyToOne @JoinColumn(name = "role-id", referencedColumnName = "id") private Role role;
      
        Purpose: Defines the user's role (e.g., Customer, Agent, Doctor, Admin, Manager).
        Relationship: Many users can be associated with one role.
      - @PrePersist protected void onCreate()
        
        Purpose: Lifecycle callback to set default values before the entity is persisted.
        Behavior: If status is not set, it defaults to 0.

    #### Field Description (Apointment)
      - doctorName
        Type: String
        Validation: @NotBlank(message = "Doctor name is required")
        Description: Ensures that the name of the doctor with whom the appointment is scheduled is provided. A blank or null value is not allowed.
  
      - department
        Type: String
        Validation: @NotBlank(message = "Department is required")
        Description: Specifies the medical department (e.g., Cardiology, Neurology) relevant to the appointment. This field must not be empty.
  
      - appointmentDate
        Type: LocalDate
        Validation:
        @NotNull(message = "Appointment date is required")
        @FutureOrPresent(message = "Appointment date cannot be in the past")
        Description: The date on which the appointment is scheduled. It must be today or a future date to prevent scheduling in the past.
  
      - appointmentTime
        Type: LocalTime
        Validation: @NotNull(message = "Appointment time is required")
        Description: The specific time of the appointment. This field ensures that the time is explicitly provided.
  
      - status
        Type: String
        Validation: @NotBlank(message = "Appointment status is required")
        Description: Indicates the current status of the appointment (e.g., Scheduled, Completed, Cancelled). This helps in tracking the appointment lifecycle.
  
      - consultationMode
        Type: String
        Validation: @NotBlank(message = "Mode of consultation is required")
        Description: Specifies how the consultation will take place‚Äîeither in-person or online. This is essential for logistical planning.
  
      - reasonForVisit
        Type: String
        Validation: @NotBlank(message = "Reason for visit is required")
        Description: Describes the patient's symptoms or the reason for seeking medical attention. This helps the doctor prepare for the consultation.
  
      - patientId
        Type: Long
        Validation: @NotNull(message = "Patient ID is required")
        Description: A unique identifier linking the appointment to a registered patient in the system. This ensures the appointment is associated with a valid patient   record.

  #### Field Description (Insurance Agent)
      - id
        Type: Long
        Annotations:
        @Id: Marks this field as the primary key.
        @GeneratedValue(strategy = GenerationType.IDENTITY): Specifies that the ID should be auto-generated by the database using the identity strategy.
        Description: A unique identifier for each insurance agent, automatically generated.
  
      - name
        Type: String
        Validation: @NotBlank(message = "Agent Name cannot be blank")
        Description: The full name of the insurance agent. This field is mandatory and cannot be empty or just whitespace.
  
      - location
          Type: String
          Validation: @NotBlank(message = "Agent location cannot be blank")
          Description: The geographical location or branch where the agent operates. Required for assigning regional responsibilities.
  
      - email
          Type: String
          Validation: @Email(message = "Invalid email format")
          Description: The agent‚Äôs email address. It must follow a valid email format but is not marked as required (optional field).
  
      - contactNo
          Type: String
          Validation: @NotBlank(message = "Agent Contact number cannot be blank")
          Description: The agent‚Äôs phone number. This is a required field for communication purposes.
  
      - services
          Type: List<Services>
          Annotations:
          @ManyToMany: Indicates a many-to-many relationship with the Services entity.
          @JoinTable(...): Specifies the join table and join columns for the relationship.
          @JsonManagedReference: Helps manage bidirectional JSON serialization.
          @NotNull(message = "Agent Services cannot be null"): Ensures the list is not null.
          @NotEmpty(message = "Insurance agent must have at least one services"): Ensures the list contains at least one service.
          Description: Represents the list of services the agent provides (e.g., life insurance, health insurance). At least one service must be associated with the agent.
  
      - agentRecords
          Type: List<CustomerServiceRecord>
          Annotation: @OneToMany(mappedBy = "insuranceAgent")
          Description: A list of customer service records linked to this agent. This is a one-to-many relationship where each record references the agent. No validation is   applied here since it's typically managed by the system.


  #### Field Description ( Medicare Service)
         - serviceName
          Type: String
          Description: It is going to search the medicare service record based service name (just as- like keyword).
  
  #### Field Description ( Health Checkup)
        -  id
            Type: Long
            Annotations:
            @Id: Marks this field as the primary key.
            @GeneratedValue(strategy = GenerationType.IDENTITY): Specifies that the ID will be auto-generated by the database.
            Description: A unique identifier for each service or plan. It is automatically generated and used for database operations.
  
      - name
            Type: String
            Validation:
            @NotBlank(message = "Name cannot be blank"): Ensures the name is not null or empty.
            @Size(max = 255, message = "Name cannot exceed 255 characters"): Limits the name length to 255 characters.
            Description: The name of the service or plan. It is a required field and must be concise yet descriptive.
  
      - description
            Type: String
            Validation:
            @Size(max = 1000, message = "Description cannot exceed 1000 characters"): Optional field, but if provided, it must not exceed 1000 characters.
            Description: A detailed explanation of the service or plan. Useful for providing additional context or features.
  
      - eligibility
            Type: String
            Validation:
            @NotBlank(message = "Eligibility cannot be blank"): Ensures the field is not empty.
            @Size(max = 50, message = "Character limit exceeded from 25 characters"): Restricts the length to 50 characters (note: message says 25, but max is 50).
            Description: Specifies who is eligible for the service (e.g., age group, employment status). This is a required field.
  
      - frequency
            Type: String
            Validation:
            @NotBlank(message = "Frequency cannot be blank"): Ensures the field is not empty.
            @Size(max = 20, message = "Character limit exceeded from 25 characters"): Restricts the length to 20 characters (again, message says 25, but max is 20).
            Description: Indicates how often the service is provided (e.g., monthly, annually). This helps in scheduling and billing.
  
      - cost
            Type: double
            Validation:
            @Positive(message = "Cost should be a positive value"): Ensures the cost is greater than zero.
            Description: The monetary cost of the service. It must be a positive value to ensure valid pricing.

            - üóÑÔ∏è Database Entities
            - AppUser: Represents users of the system.
            - HealthCheckup: Represents available health checkup packages.
            - CustomerHealthCheckupApplication: Central entity that links users to checkups.
              
            #### - Relationships:
               - CustomerHealthCheckupApplication ‚Üí AppUser: Many-to-One
               -  CustomerHealthCheckupApplication ‚Üí HealthCheckup: Many-to-One
          
                 This mapping results in a structure like: 
          
                  Table: user_health_checkup_application 
                  ------------------------------------------------------------------- 
                  | id | application_date | status | appUser_id | health_checkup_id | 
                  -------------------------------------------------------------------
                 
                
                appUser_id ‚Üí Foreign key to AppUser table 
  
  #### Field Description ( Medical Report)
        - id
          Type: Long
          Annotations:
          @Id: Marks this field as the primary key.
          @GeneratedValue(strategy = GenerationType.IDENTITY): Specifies that the ID will be auto-generated by the database.
          Description: A unique identifier for each report record, automatically generated.
  
      - reportId
          Type: String
          Annotations:
          @Column(unique = true, nullable = false): Ensures the report ID is unique and cannot be null.
          Description: A custom or system-generated unique identifier for the report (e.g., "REP-2025-001"). It is mandatory and must be unique across all reports.
  
      - customer
          Type: AppUser
          Annotations:
          @ManyToOne(fetch = FetchType.LAZY): Defines a many-to-one relationship with the AppUser entity, using lazy loading to optimize performance.
          @JoinColumn(name = "user_id", nullable = false): Specifies the foreign key column and ensures it cannot be null.
          Description: Links the report to a specific user (customer) who owns or requested the report. This relationship is required.
  
      - reportName
          Type: String
          Annotations:
          @Column(nullable = false): Ensures the report name is not null.
          Description: The title or name of the report (e.g., "Annual Health Summary"). It is a required field for identification and display purposes.
  
      - reportContent
          Type: String
          Annotations:
          @Column(nullable = false): Ensures the content is not null.
          Description: The actual content or body of the report, which may include text, summaries, or encoded data. This is a required field.
  
      - reportDate
          Type: LocalDate
          Annotations:
          @Column(nullable = false): Ensures the date is not null.
          Description: The date when the report was generated or submitted. This helps in tracking and filtering reports chronologically.

---

## üìà 6. Testing & Validation
- Unit and integration tests demonstration.
- Sonarqube reports, Code coverage.
- We tried to achieve coverage percentage of each of the test classes with valid test method, and ensured to be reliabile and correctness.

---

## üöÄ 7. Future Plans
- UI/Frontend plans (React, Angular, etc.)
- CI/CD pipeline
- Dockerization and deployment
- Scalability and performance improvements

---

## üìã 8. Demo (Live or Recorded)
- Using Postman or Swagger to:
  - Show API requests and responses.
  - Simulate real-world use cases.

---

## üìÑ 9. Documentation
- A README with:
  - Setup instructions
  - API documentation

---

## üéØ 10. Q&A and Feedback
- Ready to answer questions about:
  - Design decisions
  - Trade-offs
  - Future enhancements

---
